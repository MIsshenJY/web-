## 实现概述

- 闭包实现（`closureStack.js`）：使用工厂函数返回封装好的接口，内部数据不可被外部直接访问。
- 原型实现（`prototypeStack.js`）：使用构造函数并把方法放在原型上，方法在实例间共享，节省内存。
- 类实现（`classStack.js`）：使用 ES6 class，语法表达与继承更直观，适合现代代码风格。

所有实现都遵循相同的外部 API（push, pop, peek, isEmpty, size, clear, toArray），方便对比与替换。

## 主要学习与思考

1. 封装与私有性

我意识到 JavaScript 的私有性是有多种实现方式：
- 闭包提供真正的私有变量（无法从实例外部直接访问），但方法会为每个实例重复创建；
- 原型和 class 则通过命名约定（如 `_items`）或新语法（`#private`）来实现私有性，前者需要通过约定来维护封装边界。

2. 内存和方法复用

将方法放在原型上（或通过 class 的原型）可以显著降低每个实例的内存开销。这在需要大量实例时尤为重要。闭包实现因为为每个实例分配单独方法，内存占用较高。

3. 语义与可维护性

class 的语法更接近传统 OOP，这使得代码更可读、便于继承与复用，也更容易被团队接受。但如果目标是严格封装，闭包在接口设计上更安全。

4. 边界行为选择

我在设计时选择让 `pop()` 与 `peek()` 在空栈时返回 `undefined`（与数组的 pop/索引行为一致），这样符合 JS 的惯例而非抛出异常。课程中可以讨论不同设计选择（返回 null / 抛错 / 使用 Option 类型的思想）。

5. 扩展思路

- 若需要不可变的堆栈，考虑返回新实例而非在原实例上 mutate；
- 若需要并发安全（例如多线程环境或共享内存），需要引入锁或不可变数据结构；
- 可考虑在 `class` 中使用 `#items` 私有字段以加强封装，并在 README 中标注兼容性需求。

## 验证结果

我在本地使用 Node.js 运行 `run.js`（示例脚本）来验证所有实现的基本操作与边界行为，输出符合预期（push/peek/pop/clear/空栈返回 undefined）。

## 结论

通过这次练习，我对闭包与原型链的区别、类语法的便利以及设计 API 时的取舍（封装 vs 性能 vs 可扩展性）有了更深刻的理解。推荐在教学中结合这三种实现方式讲解，让学生在对比中掌握概念。

---

如需，我可以：
- 把 `ClassStack` 改用私有字段 `#items` 并说明如何用 Babel 转译以兼容旧浏览器/Node；
- 为每个实现加上单元测试（Jest）并把测试命令添加到 `package.json`；
- 将示例打包成一个简单网页，便于在课堂上展示交互式演示。
