# JavaScript 中实现堆栈的三种方式：闭包、原型（prototype）与类（class）

本文档展示并对比三种常见的堆栈（Stack）实现方法：使用函数闭包、构造函数 + 原型、以及 ES6 class。每种实现都包含示例 API（push, pop, peek, isEmpty, size, clear, toArray）。

## 源代码文件

- `closureStack.js` — 使用闭包实现，数据私有且封装性强。
- `prototypeStack.js` — 使用构造函数和原型链实现，方法在原型上共享，节省内存。
- `classStack.js` — 使用 ES6 class 语法实现，语法清晰，易于阅读与扩展。
- `example-run.js` — 在 Node.js 下演示三种实现的行为。

## API 约定

所有实现都遵循同样的简化 API：

- push(value): 添加元素并返回 this（允许链式调用）
- pop(): 弹出并返回栈顶元素
- peek(): 返回栈顶元素但不弹出
- isEmpty(): 返回是否为空（布尔）
- size(): 返回当前元素数量
- clear(): 清空栈并返回 this
- toArray(): 返回元素浅拷贝（从底到顶）

## 实现对比（优缺点）

1. 闭包（`closureStack.js`）
  - 优点：真正的私有数据，外部无法直接访问或修改内部数组。
  - 缺点：每次调用 `createClosureStack()` 都会新建一套方法（占用更多内存，方法无法共享）。
  - 适用场景：需要强封装、限制外部访问时，或做小型模块时使用。

2. 原型（`prototypeStack.js`）
  - 优点：方法定义在原型上，所有实例共享，节省内存；兼容老式 JS 环境。
  - 缺点：内部数组是实例属性，仍然能被外部通过属性名访问（例如 `inst._items`），因此封装不如闭包。
  - 适用场景：需要创建大量实例且关注内存占用时使用。

3. 类（`classStack.js`）
  - 优点：语法现代、可读性好、支持继承（extends）、更契合现代项目风格。
  - 缺点：私有性仍依赖约定（下划线）或需要使用私有字段（#），老环境需转译。
  - 适用场景：现代代码库、需要继承或与其他类互操作时使用。

## 性能与内存（简要）

- 对于单个实例，三者在常见操作（push/pop）上性能差异可忽略不计。
- 当创建大量实例时，原型/类（方法共享）在内存占用方面通常优于闭包实现。

## 安全与封装

- 闭包提供最强的数据私有性。
- 类与原型更依赖命名约定（例如 `_items`）或使用私有字段（例如 `#items`）来实现私有性。

## 扩展性与继承

- 原型和类都可以通过 prototype 或 extends 机制进行继承和方法复用。
- 闭包实现不适合直接继承；要扩展需在工厂函数中组合或返回更多方法。

## 何时选择哪种实现

- 需要严格封装、接口稳定：选择闭包。
- 需要在大量实例间复用方法、节省内存：选择原型或 class（首选 class）。
- 在现代项目中，优先使用 class（可读性 + 可维护性）。在考虑兼容或性能时，可选原型模式。

## 使用示例

在包含这些文件的目录下，用 Node.js 运行 `example-run.js`：

```bash
node example-run.js
```

输出将展示三种实现的行为（size、peek、pop 等）。

## 下一步建议

- 如果你想把实现做得更严格，可以把 `classStack.js` 改用私有字段（`#items`）并导出一个工厂函数以兼容旧环境。
- 添加单元测试（例如使用 Jest）覆盖常见边界：对空栈 pop、push 大量数据、并发访问（如果在异步上下文中模拟）。

---

如果想，我可以：

- 把 `ClassStack` 改成使用私有字段 `#items` 并更新示例；
- 为每个实现添加 Jest 单元测试文件并在 README 中添加运行命令；
- 或将示例打包为浏览器可用的脚本并演示在网页中使用。
